package service

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/hablof/product-registration/internal/service.Repo -o ./internal\service\repo_mock_test.go -n RepoMock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/hablof/product-registration/internal/models"
)

// RepoMock implements Repo
type RepoMock struct {
	t minimock.Tester

	funcManageProducts          func(sellerId uint64, productsToAdd []models.Product, productsToDelete []models.Product, productsToUpdate []models.Product) (u1 UpdateResults, err error)
	inspectFuncManageProducts   func(sellerId uint64, productsToAdd []models.Product, productsToDelete []models.Product, productsToUpdate []models.Product)
	afterManageProductsCounter  uint64
	beforeManageProductsCounter uint64
	ManageProductsMock          mRepoMockManageProducts

	funcSellerProductIDs          func(sellerId uint64) (ua1 []uint64, err error)
	inspectFuncSellerProductIDs   func(sellerId uint64)
	afterSellerProductIDsCounter  uint64
	beforeSellerProductIDsCounter uint64
	SellerProductIDsMock          mRepoMockSellerProductIDs

	funcSellerProducts          func(sellerId uint64) (pa1 []models.Product, err error)
	inspectFuncSellerProducts   func(sellerId uint64)
	afterSellerProductsCounter  uint64
	beforeSellerProductsCounter uint64
	SellerProductsMock          mRepoMockSellerProducts
}

// NewRepoMock returns a mock for Repo
func NewRepoMock(t minimock.Tester) *RepoMock {
	m := &RepoMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ManageProductsMock = mRepoMockManageProducts{mock: m}
	m.ManageProductsMock.callArgs = []*RepoMockManageProductsParams{}

	m.SellerProductIDsMock = mRepoMockSellerProductIDs{mock: m}
	m.SellerProductIDsMock.callArgs = []*RepoMockSellerProductIDsParams{}

	m.SellerProductsMock = mRepoMockSellerProducts{mock: m}
	m.SellerProductsMock.callArgs = []*RepoMockSellerProductsParams{}

	return m
}

type mRepoMockManageProducts struct {
	mock               *RepoMock
	defaultExpectation *RepoMockManageProductsExpectation
	expectations       []*RepoMockManageProductsExpectation

	callArgs []*RepoMockManageProductsParams
	mutex    sync.RWMutex
}

// RepoMockManageProductsExpectation specifies expectation struct of the Repo.ManageProducts
type RepoMockManageProductsExpectation struct {
	mock    *RepoMock
	params  *RepoMockManageProductsParams
	results *RepoMockManageProductsResults
	Counter uint64
}

// RepoMockManageProductsParams contains parameters of the Repo.ManageProducts
type RepoMockManageProductsParams struct {
	sellerId         uint64
	productsToAdd    []models.Product
	productsToDelete []models.Product
	productsToUpdate []models.Product
}

// RepoMockManageProductsResults contains results of the Repo.ManageProducts
type RepoMockManageProductsResults struct {
	u1  UpdateResults
	err error
}

// Expect sets up expected params for Repo.ManageProducts
func (mmManageProducts *mRepoMockManageProducts) Expect(sellerId uint64, productsToAdd []models.Product, productsToDelete []models.Product, productsToUpdate []models.Product) *mRepoMockManageProducts {
	if mmManageProducts.mock.funcManageProducts != nil {
		mmManageProducts.mock.t.Fatalf("RepoMock.ManageProducts mock is already set by Set")
	}

	if mmManageProducts.defaultExpectation == nil {
		mmManageProducts.defaultExpectation = &RepoMockManageProductsExpectation{}
	}

	mmManageProducts.defaultExpectation.params = &RepoMockManageProductsParams{sellerId, productsToAdd, productsToDelete, productsToUpdate}
	for _, e := range mmManageProducts.expectations {
		if minimock.Equal(e.params, mmManageProducts.defaultExpectation.params) {
			mmManageProducts.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmManageProducts.defaultExpectation.params)
		}
	}

	return mmManageProducts
}

// Inspect accepts an inspector function that has same arguments as the Repo.ManageProducts
func (mmManageProducts *mRepoMockManageProducts) Inspect(f func(sellerId uint64, productsToAdd []models.Product, productsToDelete []models.Product, productsToUpdate []models.Product)) *mRepoMockManageProducts {
	if mmManageProducts.mock.inspectFuncManageProducts != nil {
		mmManageProducts.mock.t.Fatalf("Inspect function is already set for RepoMock.ManageProducts")
	}

	mmManageProducts.mock.inspectFuncManageProducts = f

	return mmManageProducts
}

// Return sets up results that will be returned by Repo.ManageProducts
func (mmManageProducts *mRepoMockManageProducts) Return(u1 UpdateResults, err error) *RepoMock {
	if mmManageProducts.mock.funcManageProducts != nil {
		mmManageProducts.mock.t.Fatalf("RepoMock.ManageProducts mock is already set by Set")
	}

	if mmManageProducts.defaultExpectation == nil {
		mmManageProducts.defaultExpectation = &RepoMockManageProductsExpectation{mock: mmManageProducts.mock}
	}
	mmManageProducts.defaultExpectation.results = &RepoMockManageProductsResults{u1, err}
	return mmManageProducts.mock
}

// Set uses given function f to mock the Repo.ManageProducts method
func (mmManageProducts *mRepoMockManageProducts) Set(f func(sellerId uint64, productsToAdd []models.Product, productsToDelete []models.Product, productsToUpdate []models.Product) (u1 UpdateResults, err error)) *RepoMock {
	if mmManageProducts.defaultExpectation != nil {
		mmManageProducts.mock.t.Fatalf("Default expectation is already set for the Repo.ManageProducts method")
	}

	if len(mmManageProducts.expectations) > 0 {
		mmManageProducts.mock.t.Fatalf("Some expectations are already set for the Repo.ManageProducts method")
	}

	mmManageProducts.mock.funcManageProducts = f
	return mmManageProducts.mock
}

// When sets expectation for the Repo.ManageProducts which will trigger the result defined by the following
// Then helper
func (mmManageProducts *mRepoMockManageProducts) When(sellerId uint64, productsToAdd []models.Product, productsToDelete []models.Product, productsToUpdate []models.Product) *RepoMockManageProductsExpectation {
	if mmManageProducts.mock.funcManageProducts != nil {
		mmManageProducts.mock.t.Fatalf("RepoMock.ManageProducts mock is already set by Set")
	}

	expectation := &RepoMockManageProductsExpectation{
		mock:   mmManageProducts.mock,
		params: &RepoMockManageProductsParams{sellerId, productsToAdd, productsToDelete, productsToUpdate},
	}
	mmManageProducts.expectations = append(mmManageProducts.expectations, expectation)
	return expectation
}

// Then sets up Repo.ManageProducts return parameters for the expectation previously defined by the When method
func (e *RepoMockManageProductsExpectation) Then(u1 UpdateResults, err error) *RepoMock {
	e.results = &RepoMockManageProductsResults{u1, err}
	return e.mock
}

// ManageProducts implements Repo
func (mmManageProducts *RepoMock) ManageProducts(sellerId uint64, productsToAdd []models.Product, productsToDelete []models.Product, productsToUpdate []models.Product) (u1 UpdateResults, err error) {
	mm_atomic.AddUint64(&mmManageProducts.beforeManageProductsCounter, 1)
	defer mm_atomic.AddUint64(&mmManageProducts.afterManageProductsCounter, 1)

	if mmManageProducts.inspectFuncManageProducts != nil {
		mmManageProducts.inspectFuncManageProducts(sellerId, productsToAdd, productsToDelete, productsToUpdate)
	}

	mm_params := &RepoMockManageProductsParams{sellerId, productsToAdd, productsToDelete, productsToUpdate}

	// Record call args
	mmManageProducts.ManageProductsMock.mutex.Lock()
	mmManageProducts.ManageProductsMock.callArgs = append(mmManageProducts.ManageProductsMock.callArgs, mm_params)
	mmManageProducts.ManageProductsMock.mutex.Unlock()

	for _, e := range mmManageProducts.ManageProductsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmManageProducts.ManageProductsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmManageProducts.ManageProductsMock.defaultExpectation.Counter, 1)
		mm_want := mmManageProducts.ManageProductsMock.defaultExpectation.params
		mm_got := RepoMockManageProductsParams{sellerId, productsToAdd, productsToDelete, productsToUpdate}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmManageProducts.t.Errorf("RepoMock.ManageProducts got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmManageProducts.ManageProductsMock.defaultExpectation.results
		if mm_results == nil {
			mmManageProducts.t.Fatal("No results are set for the RepoMock.ManageProducts")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmManageProducts.funcManageProducts != nil {
		return mmManageProducts.funcManageProducts(sellerId, productsToAdd, productsToDelete, productsToUpdate)
	}
	mmManageProducts.t.Fatalf("Unexpected call to RepoMock.ManageProducts. %v %v %v %v", sellerId, productsToAdd, productsToDelete, productsToUpdate)
	return
}

// ManageProductsAfterCounter returns a count of finished RepoMock.ManageProducts invocations
func (mmManageProducts *RepoMock) ManageProductsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmManageProducts.afterManageProductsCounter)
}

// ManageProductsBeforeCounter returns a count of RepoMock.ManageProducts invocations
func (mmManageProducts *RepoMock) ManageProductsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmManageProducts.beforeManageProductsCounter)
}

// Calls returns a list of arguments used in each call to RepoMock.ManageProducts.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmManageProducts *mRepoMockManageProducts) Calls() []*RepoMockManageProductsParams {
	mmManageProducts.mutex.RLock()

	argCopy := make([]*RepoMockManageProductsParams, len(mmManageProducts.callArgs))
	copy(argCopy, mmManageProducts.callArgs)

	mmManageProducts.mutex.RUnlock()

	return argCopy
}

// MinimockManageProductsDone returns true if the count of the ManageProducts invocations corresponds
// the number of defined expectations
func (m *RepoMock) MinimockManageProductsDone() bool {
	for _, e := range m.ManageProductsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ManageProductsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterManageProductsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcManageProducts != nil && mm_atomic.LoadUint64(&m.afterManageProductsCounter) < 1 {
		return false
	}
	return true
}

// MinimockManageProductsInspect logs each unmet expectation
func (m *RepoMock) MinimockManageProductsInspect() {
	for _, e := range m.ManageProductsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepoMock.ManageProducts with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ManageProductsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterManageProductsCounter) < 1 {
		if m.ManageProductsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepoMock.ManageProducts")
		} else {
			m.t.Errorf("Expected call to RepoMock.ManageProducts with params: %#v", *m.ManageProductsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcManageProducts != nil && mm_atomic.LoadUint64(&m.afterManageProductsCounter) < 1 {
		m.t.Error("Expected call to RepoMock.ManageProducts")
	}
}

type mRepoMockSellerProductIDs struct {
	mock               *RepoMock
	defaultExpectation *RepoMockSellerProductIDsExpectation
	expectations       []*RepoMockSellerProductIDsExpectation

	callArgs []*RepoMockSellerProductIDsParams
	mutex    sync.RWMutex
}

// RepoMockSellerProductIDsExpectation specifies expectation struct of the Repo.SellerProductIDs
type RepoMockSellerProductIDsExpectation struct {
	mock    *RepoMock
	params  *RepoMockSellerProductIDsParams
	results *RepoMockSellerProductIDsResults
	Counter uint64
}

// RepoMockSellerProductIDsParams contains parameters of the Repo.SellerProductIDs
type RepoMockSellerProductIDsParams struct {
	sellerId uint64
}

// RepoMockSellerProductIDsResults contains results of the Repo.SellerProductIDs
type RepoMockSellerProductIDsResults struct {
	ua1 []uint64
	err error
}

// Expect sets up expected params for Repo.SellerProductIDs
func (mmSellerProductIDs *mRepoMockSellerProductIDs) Expect(sellerId uint64) *mRepoMockSellerProductIDs {
	if mmSellerProductIDs.mock.funcSellerProductIDs != nil {
		mmSellerProductIDs.mock.t.Fatalf("RepoMock.SellerProductIDs mock is already set by Set")
	}

	if mmSellerProductIDs.defaultExpectation == nil {
		mmSellerProductIDs.defaultExpectation = &RepoMockSellerProductIDsExpectation{}
	}

	mmSellerProductIDs.defaultExpectation.params = &RepoMockSellerProductIDsParams{sellerId}
	for _, e := range mmSellerProductIDs.expectations {
		if minimock.Equal(e.params, mmSellerProductIDs.defaultExpectation.params) {
			mmSellerProductIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSellerProductIDs.defaultExpectation.params)
		}
	}

	return mmSellerProductIDs
}

// Inspect accepts an inspector function that has same arguments as the Repo.SellerProductIDs
func (mmSellerProductIDs *mRepoMockSellerProductIDs) Inspect(f func(sellerId uint64)) *mRepoMockSellerProductIDs {
	if mmSellerProductIDs.mock.inspectFuncSellerProductIDs != nil {
		mmSellerProductIDs.mock.t.Fatalf("Inspect function is already set for RepoMock.SellerProductIDs")
	}

	mmSellerProductIDs.mock.inspectFuncSellerProductIDs = f

	return mmSellerProductIDs
}

// Return sets up results that will be returned by Repo.SellerProductIDs
func (mmSellerProductIDs *mRepoMockSellerProductIDs) Return(ua1 []uint64, err error) *RepoMock {
	if mmSellerProductIDs.mock.funcSellerProductIDs != nil {
		mmSellerProductIDs.mock.t.Fatalf("RepoMock.SellerProductIDs mock is already set by Set")
	}

	if mmSellerProductIDs.defaultExpectation == nil {
		mmSellerProductIDs.defaultExpectation = &RepoMockSellerProductIDsExpectation{mock: mmSellerProductIDs.mock}
	}
	mmSellerProductIDs.defaultExpectation.results = &RepoMockSellerProductIDsResults{ua1, err}
	return mmSellerProductIDs.mock
}

// Set uses given function f to mock the Repo.SellerProductIDs method
func (mmSellerProductIDs *mRepoMockSellerProductIDs) Set(f func(sellerId uint64) (ua1 []uint64, err error)) *RepoMock {
	if mmSellerProductIDs.defaultExpectation != nil {
		mmSellerProductIDs.mock.t.Fatalf("Default expectation is already set for the Repo.SellerProductIDs method")
	}

	if len(mmSellerProductIDs.expectations) > 0 {
		mmSellerProductIDs.mock.t.Fatalf("Some expectations are already set for the Repo.SellerProductIDs method")
	}

	mmSellerProductIDs.mock.funcSellerProductIDs = f
	return mmSellerProductIDs.mock
}

// When sets expectation for the Repo.SellerProductIDs which will trigger the result defined by the following
// Then helper
func (mmSellerProductIDs *mRepoMockSellerProductIDs) When(sellerId uint64) *RepoMockSellerProductIDsExpectation {
	if mmSellerProductIDs.mock.funcSellerProductIDs != nil {
		mmSellerProductIDs.mock.t.Fatalf("RepoMock.SellerProductIDs mock is already set by Set")
	}

	expectation := &RepoMockSellerProductIDsExpectation{
		mock:   mmSellerProductIDs.mock,
		params: &RepoMockSellerProductIDsParams{sellerId},
	}
	mmSellerProductIDs.expectations = append(mmSellerProductIDs.expectations, expectation)
	return expectation
}

// Then sets up Repo.SellerProductIDs return parameters for the expectation previously defined by the When method
func (e *RepoMockSellerProductIDsExpectation) Then(ua1 []uint64, err error) *RepoMock {
	e.results = &RepoMockSellerProductIDsResults{ua1, err}
	return e.mock
}

// SellerProductIDs implements Repo
func (mmSellerProductIDs *RepoMock) SellerProductIDs(sellerId uint64) (ua1 []uint64, err error) {
	mm_atomic.AddUint64(&mmSellerProductIDs.beforeSellerProductIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmSellerProductIDs.afterSellerProductIDsCounter, 1)

	if mmSellerProductIDs.inspectFuncSellerProductIDs != nil {
		mmSellerProductIDs.inspectFuncSellerProductIDs(sellerId)
	}

	mm_params := &RepoMockSellerProductIDsParams{sellerId}

	// Record call args
	mmSellerProductIDs.SellerProductIDsMock.mutex.Lock()
	mmSellerProductIDs.SellerProductIDsMock.callArgs = append(mmSellerProductIDs.SellerProductIDsMock.callArgs, mm_params)
	mmSellerProductIDs.SellerProductIDsMock.mutex.Unlock()

	for _, e := range mmSellerProductIDs.SellerProductIDsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ua1, e.results.err
		}
	}

	if mmSellerProductIDs.SellerProductIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSellerProductIDs.SellerProductIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmSellerProductIDs.SellerProductIDsMock.defaultExpectation.params
		mm_got := RepoMockSellerProductIDsParams{sellerId}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSellerProductIDs.t.Errorf("RepoMock.SellerProductIDs got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSellerProductIDs.SellerProductIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmSellerProductIDs.t.Fatal("No results are set for the RepoMock.SellerProductIDs")
		}
		return (*mm_results).ua1, (*mm_results).err
	}
	if mmSellerProductIDs.funcSellerProductIDs != nil {
		return mmSellerProductIDs.funcSellerProductIDs(sellerId)
	}
	mmSellerProductIDs.t.Fatalf("Unexpected call to RepoMock.SellerProductIDs. %v", sellerId)
	return
}

// SellerProductIDsAfterCounter returns a count of finished RepoMock.SellerProductIDs invocations
func (mmSellerProductIDs *RepoMock) SellerProductIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSellerProductIDs.afterSellerProductIDsCounter)
}

// SellerProductIDsBeforeCounter returns a count of RepoMock.SellerProductIDs invocations
func (mmSellerProductIDs *RepoMock) SellerProductIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSellerProductIDs.beforeSellerProductIDsCounter)
}

// Calls returns a list of arguments used in each call to RepoMock.SellerProductIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSellerProductIDs *mRepoMockSellerProductIDs) Calls() []*RepoMockSellerProductIDsParams {
	mmSellerProductIDs.mutex.RLock()

	argCopy := make([]*RepoMockSellerProductIDsParams, len(mmSellerProductIDs.callArgs))
	copy(argCopy, mmSellerProductIDs.callArgs)

	mmSellerProductIDs.mutex.RUnlock()

	return argCopy
}

// MinimockSellerProductIDsDone returns true if the count of the SellerProductIDs invocations corresponds
// the number of defined expectations
func (m *RepoMock) MinimockSellerProductIDsDone() bool {
	for _, e := range m.SellerProductIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SellerProductIDsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSellerProductIDsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSellerProductIDs != nil && mm_atomic.LoadUint64(&m.afterSellerProductIDsCounter) < 1 {
		return false
	}
	return true
}

// MinimockSellerProductIDsInspect logs each unmet expectation
func (m *RepoMock) MinimockSellerProductIDsInspect() {
	for _, e := range m.SellerProductIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepoMock.SellerProductIDs with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SellerProductIDsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSellerProductIDsCounter) < 1 {
		if m.SellerProductIDsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepoMock.SellerProductIDs")
		} else {
			m.t.Errorf("Expected call to RepoMock.SellerProductIDs with params: %#v", *m.SellerProductIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSellerProductIDs != nil && mm_atomic.LoadUint64(&m.afterSellerProductIDsCounter) < 1 {
		m.t.Error("Expected call to RepoMock.SellerProductIDs")
	}
}

type mRepoMockSellerProducts struct {
	mock               *RepoMock
	defaultExpectation *RepoMockSellerProductsExpectation
	expectations       []*RepoMockSellerProductsExpectation

	callArgs []*RepoMockSellerProductsParams
	mutex    sync.RWMutex
}

// RepoMockSellerProductsExpectation specifies expectation struct of the Repo.SellerProducts
type RepoMockSellerProductsExpectation struct {
	mock    *RepoMock
	params  *RepoMockSellerProductsParams
	results *RepoMockSellerProductsResults
	Counter uint64
}

// RepoMockSellerProductsParams contains parameters of the Repo.SellerProducts
type RepoMockSellerProductsParams struct {
	sellerId uint64
}

// RepoMockSellerProductsResults contains results of the Repo.SellerProducts
type RepoMockSellerProductsResults struct {
	pa1 []models.Product
	err error
}

// Expect sets up expected params for Repo.SellerProducts
func (mmSellerProducts *mRepoMockSellerProducts) Expect(sellerId uint64) *mRepoMockSellerProducts {
	if mmSellerProducts.mock.funcSellerProducts != nil {
		mmSellerProducts.mock.t.Fatalf("RepoMock.SellerProducts mock is already set by Set")
	}

	if mmSellerProducts.defaultExpectation == nil {
		mmSellerProducts.defaultExpectation = &RepoMockSellerProductsExpectation{}
	}

	mmSellerProducts.defaultExpectation.params = &RepoMockSellerProductsParams{sellerId}
	for _, e := range mmSellerProducts.expectations {
		if minimock.Equal(e.params, mmSellerProducts.defaultExpectation.params) {
			mmSellerProducts.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSellerProducts.defaultExpectation.params)
		}
	}

	return mmSellerProducts
}

// Inspect accepts an inspector function that has same arguments as the Repo.SellerProducts
func (mmSellerProducts *mRepoMockSellerProducts) Inspect(f func(sellerId uint64)) *mRepoMockSellerProducts {
	if mmSellerProducts.mock.inspectFuncSellerProducts != nil {
		mmSellerProducts.mock.t.Fatalf("Inspect function is already set for RepoMock.SellerProducts")
	}

	mmSellerProducts.mock.inspectFuncSellerProducts = f

	return mmSellerProducts
}

// Return sets up results that will be returned by Repo.SellerProducts
func (mmSellerProducts *mRepoMockSellerProducts) Return(pa1 []models.Product, err error) *RepoMock {
	if mmSellerProducts.mock.funcSellerProducts != nil {
		mmSellerProducts.mock.t.Fatalf("RepoMock.SellerProducts mock is already set by Set")
	}

	if mmSellerProducts.defaultExpectation == nil {
		mmSellerProducts.defaultExpectation = &RepoMockSellerProductsExpectation{mock: mmSellerProducts.mock}
	}
	mmSellerProducts.defaultExpectation.results = &RepoMockSellerProductsResults{pa1, err}
	return mmSellerProducts.mock
}

// Set uses given function f to mock the Repo.SellerProducts method
func (mmSellerProducts *mRepoMockSellerProducts) Set(f func(sellerId uint64) (pa1 []models.Product, err error)) *RepoMock {
	if mmSellerProducts.defaultExpectation != nil {
		mmSellerProducts.mock.t.Fatalf("Default expectation is already set for the Repo.SellerProducts method")
	}

	if len(mmSellerProducts.expectations) > 0 {
		mmSellerProducts.mock.t.Fatalf("Some expectations are already set for the Repo.SellerProducts method")
	}

	mmSellerProducts.mock.funcSellerProducts = f
	return mmSellerProducts.mock
}

// When sets expectation for the Repo.SellerProducts which will trigger the result defined by the following
// Then helper
func (mmSellerProducts *mRepoMockSellerProducts) When(sellerId uint64) *RepoMockSellerProductsExpectation {
	if mmSellerProducts.mock.funcSellerProducts != nil {
		mmSellerProducts.mock.t.Fatalf("RepoMock.SellerProducts mock is already set by Set")
	}

	expectation := &RepoMockSellerProductsExpectation{
		mock:   mmSellerProducts.mock,
		params: &RepoMockSellerProductsParams{sellerId},
	}
	mmSellerProducts.expectations = append(mmSellerProducts.expectations, expectation)
	return expectation
}

// Then sets up Repo.SellerProducts return parameters for the expectation previously defined by the When method
func (e *RepoMockSellerProductsExpectation) Then(pa1 []models.Product, err error) *RepoMock {
	e.results = &RepoMockSellerProductsResults{pa1, err}
	return e.mock
}

// SellerProducts implements Repo
func (mmSellerProducts *RepoMock) SellerProducts(sellerId uint64) (pa1 []models.Product, err error) {
	mm_atomic.AddUint64(&mmSellerProducts.beforeSellerProductsCounter, 1)
	defer mm_atomic.AddUint64(&mmSellerProducts.afterSellerProductsCounter, 1)

	if mmSellerProducts.inspectFuncSellerProducts != nil {
		mmSellerProducts.inspectFuncSellerProducts(sellerId)
	}

	mm_params := &RepoMockSellerProductsParams{sellerId}

	// Record call args
	mmSellerProducts.SellerProductsMock.mutex.Lock()
	mmSellerProducts.SellerProductsMock.callArgs = append(mmSellerProducts.SellerProductsMock.callArgs, mm_params)
	mmSellerProducts.SellerProductsMock.mutex.Unlock()

	for _, e := range mmSellerProducts.SellerProductsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.err
		}
	}

	if mmSellerProducts.SellerProductsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSellerProducts.SellerProductsMock.defaultExpectation.Counter, 1)
		mm_want := mmSellerProducts.SellerProductsMock.defaultExpectation.params
		mm_got := RepoMockSellerProductsParams{sellerId}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSellerProducts.t.Errorf("RepoMock.SellerProducts got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSellerProducts.SellerProductsMock.defaultExpectation.results
		if mm_results == nil {
			mmSellerProducts.t.Fatal("No results are set for the RepoMock.SellerProducts")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmSellerProducts.funcSellerProducts != nil {
		return mmSellerProducts.funcSellerProducts(sellerId)
	}
	mmSellerProducts.t.Fatalf("Unexpected call to RepoMock.SellerProducts. %v", sellerId)
	return
}

// SellerProductsAfterCounter returns a count of finished RepoMock.SellerProducts invocations
func (mmSellerProducts *RepoMock) SellerProductsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSellerProducts.afterSellerProductsCounter)
}

// SellerProductsBeforeCounter returns a count of RepoMock.SellerProducts invocations
func (mmSellerProducts *RepoMock) SellerProductsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSellerProducts.beforeSellerProductsCounter)
}

// Calls returns a list of arguments used in each call to RepoMock.SellerProducts.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSellerProducts *mRepoMockSellerProducts) Calls() []*RepoMockSellerProductsParams {
	mmSellerProducts.mutex.RLock()

	argCopy := make([]*RepoMockSellerProductsParams, len(mmSellerProducts.callArgs))
	copy(argCopy, mmSellerProducts.callArgs)

	mmSellerProducts.mutex.RUnlock()

	return argCopy
}

// MinimockSellerProductsDone returns true if the count of the SellerProducts invocations corresponds
// the number of defined expectations
func (m *RepoMock) MinimockSellerProductsDone() bool {
	for _, e := range m.SellerProductsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SellerProductsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSellerProductsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSellerProducts != nil && mm_atomic.LoadUint64(&m.afterSellerProductsCounter) < 1 {
		return false
	}
	return true
}

// MinimockSellerProductsInspect logs each unmet expectation
func (m *RepoMock) MinimockSellerProductsInspect() {
	for _, e := range m.SellerProductsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepoMock.SellerProducts with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SellerProductsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSellerProductsCounter) < 1 {
		if m.SellerProductsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepoMock.SellerProducts")
		} else {
			m.t.Errorf("Expected call to RepoMock.SellerProducts with params: %#v", *m.SellerProductsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSellerProducts != nil && mm_atomic.LoadUint64(&m.afterSellerProductsCounter) < 1 {
		m.t.Error("Expected call to RepoMock.SellerProducts")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepoMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockManageProductsInspect()

		m.MinimockSellerProductIDsInspect()

		m.MinimockSellerProductsInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockManageProductsDone() &&
		m.MinimockSellerProductIDsDone() &&
		m.MinimockSellerProductsDone()
}
