package service

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/hablof/product-registration/internal/service.Repository -o ./internal\service\repository_mock_test.go -n RepositoryMock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/hablof/product-registration/internal/models"
)

// RepositoryMock implements Repository
type RepositoryMock struct {
	t minimock.Tester

	funcManageProducts          func(sellerId uint64, productsToAdd []models.Product, productsToDelete []models.Product, productsToUpdate []models.Product) (err error)
	inspectFuncManageProducts   func(sellerId uint64, productsToAdd []models.Product, productsToDelete []models.Product, productsToUpdate []models.Product)
	afterManageProductsCounter  uint64
	beforeManageProductsCounter uint64
	ManageProductsMock          mRepositoryMockManageProducts

	funcProductsByFilter          func(filter RequestFilter) (pa1 []models.Product, err error)
	inspectFuncProductsByFilter   func(filter RequestFilter)
	afterProductsByFilterCounter  uint64
	beforeProductsByFilterCounter uint64
	ProductsByFilterMock          mRepositoryMockProductsByFilter

	funcSellerProductIDs          func(sellerId uint64) (ua1 []uint64, err error)
	inspectFuncSellerProductIDs   func(sellerId uint64)
	afterSellerProductIDsCounter  uint64
	beforeSellerProductIDsCounter uint64
	SellerProductIDsMock          mRepositoryMockSellerProductIDs

	funcSellerProducts          func(sellerId uint64) (pa1 []models.Product, err error)
	inspectFuncSellerProducts   func(sellerId uint64)
	afterSellerProductsCounter  uint64
	beforeSellerProductsCounter uint64
	SellerProductsMock          mRepositoryMockSellerProducts
}

// NewRepositoryMock returns a mock for Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ManageProductsMock = mRepositoryMockManageProducts{mock: m}
	m.ManageProductsMock.callArgs = []*RepositoryMockManageProductsParams{}

	m.ProductsByFilterMock = mRepositoryMockProductsByFilter{mock: m}
	m.ProductsByFilterMock.callArgs = []*RepositoryMockProductsByFilterParams{}

	m.SellerProductIDsMock = mRepositoryMockSellerProductIDs{mock: m}
	m.SellerProductIDsMock.callArgs = []*RepositoryMockSellerProductIDsParams{}

	m.SellerProductsMock = mRepositoryMockSellerProducts{mock: m}
	m.SellerProductsMock.callArgs = []*RepositoryMockSellerProductsParams{}

	return m
}

type mRepositoryMockManageProducts struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockManageProductsExpectation
	expectations       []*RepositoryMockManageProductsExpectation

	callArgs []*RepositoryMockManageProductsParams
	mutex    sync.RWMutex
}

// RepositoryMockManageProductsExpectation specifies expectation struct of the Repository.ManageProducts
type RepositoryMockManageProductsExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockManageProductsParams
	results *RepositoryMockManageProductsResults
	Counter uint64
}

// RepositoryMockManageProductsParams contains parameters of the Repository.ManageProducts
type RepositoryMockManageProductsParams struct {
	sellerId         uint64
	productsToAdd    []models.Product
	productsToDelete []models.Product
	productsToUpdate []models.Product
}

// RepositoryMockManageProductsResults contains results of the Repository.ManageProducts
type RepositoryMockManageProductsResults struct {
	err error
}

// Expect sets up expected params for Repository.ManageProducts
func (mmManageProducts *mRepositoryMockManageProducts) Expect(sellerId uint64, productsToAdd []models.Product, productsToDelete []models.Product, productsToUpdate []models.Product) *mRepositoryMockManageProducts {
	if mmManageProducts.mock.funcManageProducts != nil {
		mmManageProducts.mock.t.Fatalf("RepositoryMock.ManageProducts mock is already set by Set")
	}

	if mmManageProducts.defaultExpectation == nil {
		mmManageProducts.defaultExpectation = &RepositoryMockManageProductsExpectation{}
	}

	mmManageProducts.defaultExpectation.params = &RepositoryMockManageProductsParams{sellerId, productsToAdd, productsToDelete, productsToUpdate}
	for _, e := range mmManageProducts.expectations {
		if minimock.Equal(e.params, mmManageProducts.defaultExpectation.params) {
			mmManageProducts.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmManageProducts.defaultExpectation.params)
		}
	}

	return mmManageProducts
}

// Inspect accepts an inspector function that has same arguments as the Repository.ManageProducts
func (mmManageProducts *mRepositoryMockManageProducts) Inspect(f func(sellerId uint64, productsToAdd []models.Product, productsToDelete []models.Product, productsToUpdate []models.Product)) *mRepositoryMockManageProducts {
	if mmManageProducts.mock.inspectFuncManageProducts != nil {
		mmManageProducts.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ManageProducts")
	}

	mmManageProducts.mock.inspectFuncManageProducts = f

	return mmManageProducts
}

// Return sets up results that will be returned by Repository.ManageProducts
func (mmManageProducts *mRepositoryMockManageProducts) Return(err error) *RepositoryMock {
	if mmManageProducts.mock.funcManageProducts != nil {
		mmManageProducts.mock.t.Fatalf("RepositoryMock.ManageProducts mock is already set by Set")
	}

	if mmManageProducts.defaultExpectation == nil {
		mmManageProducts.defaultExpectation = &RepositoryMockManageProductsExpectation{mock: mmManageProducts.mock}
	}
	mmManageProducts.defaultExpectation.results = &RepositoryMockManageProductsResults{err}
	return mmManageProducts.mock
}

// Set uses given function f to mock the Repository.ManageProducts method
func (mmManageProducts *mRepositoryMockManageProducts) Set(f func(sellerId uint64, productsToAdd []models.Product, productsToDelete []models.Product, productsToUpdate []models.Product) (err error)) *RepositoryMock {
	if mmManageProducts.defaultExpectation != nil {
		mmManageProducts.mock.t.Fatalf("Default expectation is already set for the Repository.ManageProducts method")
	}

	if len(mmManageProducts.expectations) > 0 {
		mmManageProducts.mock.t.Fatalf("Some expectations are already set for the Repository.ManageProducts method")
	}

	mmManageProducts.mock.funcManageProducts = f
	return mmManageProducts.mock
}

// When sets expectation for the Repository.ManageProducts which will trigger the result defined by the following
// Then helper
func (mmManageProducts *mRepositoryMockManageProducts) When(sellerId uint64, productsToAdd []models.Product, productsToDelete []models.Product, productsToUpdate []models.Product) *RepositoryMockManageProductsExpectation {
	if mmManageProducts.mock.funcManageProducts != nil {
		mmManageProducts.mock.t.Fatalf("RepositoryMock.ManageProducts mock is already set by Set")
	}

	expectation := &RepositoryMockManageProductsExpectation{
		mock:   mmManageProducts.mock,
		params: &RepositoryMockManageProductsParams{sellerId, productsToAdd, productsToDelete, productsToUpdate},
	}
	mmManageProducts.expectations = append(mmManageProducts.expectations, expectation)
	return expectation
}

// Then sets up Repository.ManageProducts return parameters for the expectation previously defined by the When method
func (e *RepositoryMockManageProductsExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockManageProductsResults{err}
	return e.mock
}

// ManageProducts implements Repository
func (mmManageProducts *RepositoryMock) ManageProducts(sellerId uint64, productsToAdd []models.Product, productsToDelete []models.Product, productsToUpdate []models.Product) (err error) {
	mm_atomic.AddUint64(&mmManageProducts.beforeManageProductsCounter, 1)
	defer mm_atomic.AddUint64(&mmManageProducts.afterManageProductsCounter, 1)

	if mmManageProducts.inspectFuncManageProducts != nil {
		mmManageProducts.inspectFuncManageProducts(sellerId, productsToAdd, productsToDelete, productsToUpdate)
	}

	mm_params := &RepositoryMockManageProductsParams{sellerId, productsToAdd, productsToDelete, productsToUpdate}

	// Record call args
	mmManageProducts.ManageProductsMock.mutex.Lock()
	mmManageProducts.ManageProductsMock.callArgs = append(mmManageProducts.ManageProductsMock.callArgs, mm_params)
	mmManageProducts.ManageProductsMock.mutex.Unlock()

	for _, e := range mmManageProducts.ManageProductsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmManageProducts.ManageProductsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmManageProducts.ManageProductsMock.defaultExpectation.Counter, 1)
		mm_want := mmManageProducts.ManageProductsMock.defaultExpectation.params
		mm_got := RepositoryMockManageProductsParams{sellerId, productsToAdd, productsToDelete, productsToUpdate}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmManageProducts.t.Errorf("RepositoryMock.ManageProducts got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmManageProducts.ManageProductsMock.defaultExpectation.results
		if mm_results == nil {
			mmManageProducts.t.Fatal("No results are set for the RepositoryMock.ManageProducts")
		}
		return (*mm_results).err
	}
	if mmManageProducts.funcManageProducts != nil {
		return mmManageProducts.funcManageProducts(sellerId, productsToAdd, productsToDelete, productsToUpdate)
	}
	mmManageProducts.t.Fatalf("Unexpected call to RepositoryMock.ManageProducts. %v %v %v %v", sellerId, productsToAdd, productsToDelete, productsToUpdate)
	return
}

// ManageProductsAfterCounter returns a count of finished RepositoryMock.ManageProducts invocations
func (mmManageProducts *RepositoryMock) ManageProductsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmManageProducts.afterManageProductsCounter)
}

// ManageProductsBeforeCounter returns a count of RepositoryMock.ManageProducts invocations
func (mmManageProducts *RepositoryMock) ManageProductsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmManageProducts.beforeManageProductsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ManageProducts.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmManageProducts *mRepositoryMockManageProducts) Calls() []*RepositoryMockManageProductsParams {
	mmManageProducts.mutex.RLock()

	argCopy := make([]*RepositoryMockManageProductsParams, len(mmManageProducts.callArgs))
	copy(argCopy, mmManageProducts.callArgs)

	mmManageProducts.mutex.RUnlock()

	return argCopy
}

// MinimockManageProductsDone returns true if the count of the ManageProducts invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockManageProductsDone() bool {
	for _, e := range m.ManageProductsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ManageProductsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterManageProductsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcManageProducts != nil && mm_atomic.LoadUint64(&m.afterManageProductsCounter) < 1 {
		return false
	}
	return true
}

// MinimockManageProductsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockManageProductsInspect() {
	for _, e := range m.ManageProductsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ManageProducts with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ManageProductsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterManageProductsCounter) < 1 {
		if m.ManageProductsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ManageProducts")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ManageProducts with params: %#v", *m.ManageProductsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcManageProducts != nil && mm_atomic.LoadUint64(&m.afterManageProductsCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.ManageProducts")
	}
}

type mRepositoryMockProductsByFilter struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockProductsByFilterExpectation
	expectations       []*RepositoryMockProductsByFilterExpectation

	callArgs []*RepositoryMockProductsByFilterParams
	mutex    sync.RWMutex
}

// RepositoryMockProductsByFilterExpectation specifies expectation struct of the Repository.ProductsByFilter
type RepositoryMockProductsByFilterExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockProductsByFilterParams
	results *RepositoryMockProductsByFilterResults
	Counter uint64
}

// RepositoryMockProductsByFilterParams contains parameters of the Repository.ProductsByFilter
type RepositoryMockProductsByFilterParams struct {
	filter RequestFilter
}

// RepositoryMockProductsByFilterResults contains results of the Repository.ProductsByFilter
type RepositoryMockProductsByFilterResults struct {
	pa1 []models.Product
	err error
}

// Expect sets up expected params for Repository.ProductsByFilter
func (mmProductsByFilter *mRepositoryMockProductsByFilter) Expect(filter RequestFilter) *mRepositoryMockProductsByFilter {
	if mmProductsByFilter.mock.funcProductsByFilter != nil {
		mmProductsByFilter.mock.t.Fatalf("RepositoryMock.ProductsByFilter mock is already set by Set")
	}

	if mmProductsByFilter.defaultExpectation == nil {
		mmProductsByFilter.defaultExpectation = &RepositoryMockProductsByFilterExpectation{}
	}

	mmProductsByFilter.defaultExpectation.params = &RepositoryMockProductsByFilterParams{filter}
	for _, e := range mmProductsByFilter.expectations {
		if minimock.Equal(e.params, mmProductsByFilter.defaultExpectation.params) {
			mmProductsByFilter.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmProductsByFilter.defaultExpectation.params)
		}
	}

	return mmProductsByFilter
}

// Inspect accepts an inspector function that has same arguments as the Repository.ProductsByFilter
func (mmProductsByFilter *mRepositoryMockProductsByFilter) Inspect(f func(filter RequestFilter)) *mRepositoryMockProductsByFilter {
	if mmProductsByFilter.mock.inspectFuncProductsByFilter != nil {
		mmProductsByFilter.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ProductsByFilter")
	}

	mmProductsByFilter.mock.inspectFuncProductsByFilter = f

	return mmProductsByFilter
}

// Return sets up results that will be returned by Repository.ProductsByFilter
func (mmProductsByFilter *mRepositoryMockProductsByFilter) Return(pa1 []models.Product, err error) *RepositoryMock {
	if mmProductsByFilter.mock.funcProductsByFilter != nil {
		mmProductsByFilter.mock.t.Fatalf("RepositoryMock.ProductsByFilter mock is already set by Set")
	}

	if mmProductsByFilter.defaultExpectation == nil {
		mmProductsByFilter.defaultExpectation = &RepositoryMockProductsByFilterExpectation{mock: mmProductsByFilter.mock}
	}
	mmProductsByFilter.defaultExpectation.results = &RepositoryMockProductsByFilterResults{pa1, err}
	return mmProductsByFilter.mock
}

// Set uses given function f to mock the Repository.ProductsByFilter method
func (mmProductsByFilter *mRepositoryMockProductsByFilter) Set(f func(filter RequestFilter) (pa1 []models.Product, err error)) *RepositoryMock {
	if mmProductsByFilter.defaultExpectation != nil {
		mmProductsByFilter.mock.t.Fatalf("Default expectation is already set for the Repository.ProductsByFilter method")
	}

	if len(mmProductsByFilter.expectations) > 0 {
		mmProductsByFilter.mock.t.Fatalf("Some expectations are already set for the Repository.ProductsByFilter method")
	}

	mmProductsByFilter.mock.funcProductsByFilter = f
	return mmProductsByFilter.mock
}

// When sets expectation for the Repository.ProductsByFilter which will trigger the result defined by the following
// Then helper
func (mmProductsByFilter *mRepositoryMockProductsByFilter) When(filter RequestFilter) *RepositoryMockProductsByFilterExpectation {
	if mmProductsByFilter.mock.funcProductsByFilter != nil {
		mmProductsByFilter.mock.t.Fatalf("RepositoryMock.ProductsByFilter mock is already set by Set")
	}

	expectation := &RepositoryMockProductsByFilterExpectation{
		mock:   mmProductsByFilter.mock,
		params: &RepositoryMockProductsByFilterParams{filter},
	}
	mmProductsByFilter.expectations = append(mmProductsByFilter.expectations, expectation)
	return expectation
}

// Then sets up Repository.ProductsByFilter return parameters for the expectation previously defined by the When method
func (e *RepositoryMockProductsByFilterExpectation) Then(pa1 []models.Product, err error) *RepositoryMock {
	e.results = &RepositoryMockProductsByFilterResults{pa1, err}
	return e.mock
}

// ProductsByFilter implements Repository
func (mmProductsByFilter *RepositoryMock) ProductsByFilter(filter RequestFilter) (pa1 []models.Product, err error) {
	mm_atomic.AddUint64(&mmProductsByFilter.beforeProductsByFilterCounter, 1)
	defer mm_atomic.AddUint64(&mmProductsByFilter.afterProductsByFilterCounter, 1)

	if mmProductsByFilter.inspectFuncProductsByFilter != nil {
		mmProductsByFilter.inspectFuncProductsByFilter(filter)
	}

	mm_params := &RepositoryMockProductsByFilterParams{filter}

	// Record call args
	mmProductsByFilter.ProductsByFilterMock.mutex.Lock()
	mmProductsByFilter.ProductsByFilterMock.callArgs = append(mmProductsByFilter.ProductsByFilterMock.callArgs, mm_params)
	mmProductsByFilter.ProductsByFilterMock.mutex.Unlock()

	for _, e := range mmProductsByFilter.ProductsByFilterMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.err
		}
	}

	if mmProductsByFilter.ProductsByFilterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmProductsByFilter.ProductsByFilterMock.defaultExpectation.Counter, 1)
		mm_want := mmProductsByFilter.ProductsByFilterMock.defaultExpectation.params
		mm_got := RepositoryMockProductsByFilterParams{filter}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmProductsByFilter.t.Errorf("RepositoryMock.ProductsByFilter got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmProductsByFilter.ProductsByFilterMock.defaultExpectation.results
		if mm_results == nil {
			mmProductsByFilter.t.Fatal("No results are set for the RepositoryMock.ProductsByFilter")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmProductsByFilter.funcProductsByFilter != nil {
		return mmProductsByFilter.funcProductsByFilter(filter)
	}
	mmProductsByFilter.t.Fatalf("Unexpected call to RepositoryMock.ProductsByFilter. %v", filter)
	return
}

// ProductsByFilterAfterCounter returns a count of finished RepositoryMock.ProductsByFilter invocations
func (mmProductsByFilter *RepositoryMock) ProductsByFilterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProductsByFilter.afterProductsByFilterCounter)
}

// ProductsByFilterBeforeCounter returns a count of RepositoryMock.ProductsByFilter invocations
func (mmProductsByFilter *RepositoryMock) ProductsByFilterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProductsByFilter.beforeProductsByFilterCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ProductsByFilter.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmProductsByFilter *mRepositoryMockProductsByFilter) Calls() []*RepositoryMockProductsByFilterParams {
	mmProductsByFilter.mutex.RLock()

	argCopy := make([]*RepositoryMockProductsByFilterParams, len(mmProductsByFilter.callArgs))
	copy(argCopy, mmProductsByFilter.callArgs)

	mmProductsByFilter.mutex.RUnlock()

	return argCopy
}

// MinimockProductsByFilterDone returns true if the count of the ProductsByFilter invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockProductsByFilterDone() bool {
	for _, e := range m.ProductsByFilterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ProductsByFilterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterProductsByFilterCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProductsByFilter != nil && mm_atomic.LoadUint64(&m.afterProductsByFilterCounter) < 1 {
		return false
	}
	return true
}

// MinimockProductsByFilterInspect logs each unmet expectation
func (m *RepositoryMock) MinimockProductsByFilterInspect() {
	for _, e := range m.ProductsByFilterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ProductsByFilter with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ProductsByFilterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterProductsByFilterCounter) < 1 {
		if m.ProductsByFilterMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ProductsByFilter")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ProductsByFilter with params: %#v", *m.ProductsByFilterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProductsByFilter != nil && mm_atomic.LoadUint64(&m.afterProductsByFilterCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.ProductsByFilter")
	}
}

type mRepositoryMockSellerProductIDs struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockSellerProductIDsExpectation
	expectations       []*RepositoryMockSellerProductIDsExpectation

	callArgs []*RepositoryMockSellerProductIDsParams
	mutex    sync.RWMutex
}

// RepositoryMockSellerProductIDsExpectation specifies expectation struct of the Repository.SellerProductIDs
type RepositoryMockSellerProductIDsExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockSellerProductIDsParams
	results *RepositoryMockSellerProductIDsResults
	Counter uint64
}

// RepositoryMockSellerProductIDsParams contains parameters of the Repository.SellerProductIDs
type RepositoryMockSellerProductIDsParams struct {
	sellerId uint64
}

// RepositoryMockSellerProductIDsResults contains results of the Repository.SellerProductIDs
type RepositoryMockSellerProductIDsResults struct {
	ua1 []uint64
	err error
}

// Expect sets up expected params for Repository.SellerProductIDs
func (mmSellerProductIDs *mRepositoryMockSellerProductIDs) Expect(sellerId uint64) *mRepositoryMockSellerProductIDs {
	if mmSellerProductIDs.mock.funcSellerProductIDs != nil {
		mmSellerProductIDs.mock.t.Fatalf("RepositoryMock.SellerProductIDs mock is already set by Set")
	}

	if mmSellerProductIDs.defaultExpectation == nil {
		mmSellerProductIDs.defaultExpectation = &RepositoryMockSellerProductIDsExpectation{}
	}

	mmSellerProductIDs.defaultExpectation.params = &RepositoryMockSellerProductIDsParams{sellerId}
	for _, e := range mmSellerProductIDs.expectations {
		if minimock.Equal(e.params, mmSellerProductIDs.defaultExpectation.params) {
			mmSellerProductIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSellerProductIDs.defaultExpectation.params)
		}
	}

	return mmSellerProductIDs
}

// Inspect accepts an inspector function that has same arguments as the Repository.SellerProductIDs
func (mmSellerProductIDs *mRepositoryMockSellerProductIDs) Inspect(f func(sellerId uint64)) *mRepositoryMockSellerProductIDs {
	if mmSellerProductIDs.mock.inspectFuncSellerProductIDs != nil {
		mmSellerProductIDs.mock.t.Fatalf("Inspect function is already set for RepositoryMock.SellerProductIDs")
	}

	mmSellerProductIDs.mock.inspectFuncSellerProductIDs = f

	return mmSellerProductIDs
}

// Return sets up results that will be returned by Repository.SellerProductIDs
func (mmSellerProductIDs *mRepositoryMockSellerProductIDs) Return(ua1 []uint64, err error) *RepositoryMock {
	if mmSellerProductIDs.mock.funcSellerProductIDs != nil {
		mmSellerProductIDs.mock.t.Fatalf("RepositoryMock.SellerProductIDs mock is already set by Set")
	}

	if mmSellerProductIDs.defaultExpectation == nil {
		mmSellerProductIDs.defaultExpectation = &RepositoryMockSellerProductIDsExpectation{mock: mmSellerProductIDs.mock}
	}
	mmSellerProductIDs.defaultExpectation.results = &RepositoryMockSellerProductIDsResults{ua1, err}
	return mmSellerProductIDs.mock
}

// Set uses given function f to mock the Repository.SellerProductIDs method
func (mmSellerProductIDs *mRepositoryMockSellerProductIDs) Set(f func(sellerId uint64) (ua1 []uint64, err error)) *RepositoryMock {
	if mmSellerProductIDs.defaultExpectation != nil {
		mmSellerProductIDs.mock.t.Fatalf("Default expectation is already set for the Repository.SellerProductIDs method")
	}

	if len(mmSellerProductIDs.expectations) > 0 {
		mmSellerProductIDs.mock.t.Fatalf("Some expectations are already set for the Repository.SellerProductIDs method")
	}

	mmSellerProductIDs.mock.funcSellerProductIDs = f
	return mmSellerProductIDs.mock
}

// When sets expectation for the Repository.SellerProductIDs which will trigger the result defined by the following
// Then helper
func (mmSellerProductIDs *mRepositoryMockSellerProductIDs) When(sellerId uint64) *RepositoryMockSellerProductIDsExpectation {
	if mmSellerProductIDs.mock.funcSellerProductIDs != nil {
		mmSellerProductIDs.mock.t.Fatalf("RepositoryMock.SellerProductIDs mock is already set by Set")
	}

	expectation := &RepositoryMockSellerProductIDsExpectation{
		mock:   mmSellerProductIDs.mock,
		params: &RepositoryMockSellerProductIDsParams{sellerId},
	}
	mmSellerProductIDs.expectations = append(mmSellerProductIDs.expectations, expectation)
	return expectation
}

// Then sets up Repository.SellerProductIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryMockSellerProductIDsExpectation) Then(ua1 []uint64, err error) *RepositoryMock {
	e.results = &RepositoryMockSellerProductIDsResults{ua1, err}
	return e.mock
}

// SellerProductIDs implements Repository
func (mmSellerProductIDs *RepositoryMock) SellerProductIDs(sellerId uint64) (ua1 []uint64, err error) {
	mm_atomic.AddUint64(&mmSellerProductIDs.beforeSellerProductIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmSellerProductIDs.afterSellerProductIDsCounter, 1)

	if mmSellerProductIDs.inspectFuncSellerProductIDs != nil {
		mmSellerProductIDs.inspectFuncSellerProductIDs(sellerId)
	}

	mm_params := &RepositoryMockSellerProductIDsParams{sellerId}

	// Record call args
	mmSellerProductIDs.SellerProductIDsMock.mutex.Lock()
	mmSellerProductIDs.SellerProductIDsMock.callArgs = append(mmSellerProductIDs.SellerProductIDsMock.callArgs, mm_params)
	mmSellerProductIDs.SellerProductIDsMock.mutex.Unlock()

	for _, e := range mmSellerProductIDs.SellerProductIDsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ua1, e.results.err
		}
	}

	if mmSellerProductIDs.SellerProductIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSellerProductIDs.SellerProductIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmSellerProductIDs.SellerProductIDsMock.defaultExpectation.params
		mm_got := RepositoryMockSellerProductIDsParams{sellerId}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSellerProductIDs.t.Errorf("RepositoryMock.SellerProductIDs got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSellerProductIDs.SellerProductIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmSellerProductIDs.t.Fatal("No results are set for the RepositoryMock.SellerProductIDs")
		}
		return (*mm_results).ua1, (*mm_results).err
	}
	if mmSellerProductIDs.funcSellerProductIDs != nil {
		return mmSellerProductIDs.funcSellerProductIDs(sellerId)
	}
	mmSellerProductIDs.t.Fatalf("Unexpected call to RepositoryMock.SellerProductIDs. %v", sellerId)
	return
}

// SellerProductIDsAfterCounter returns a count of finished RepositoryMock.SellerProductIDs invocations
func (mmSellerProductIDs *RepositoryMock) SellerProductIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSellerProductIDs.afterSellerProductIDsCounter)
}

// SellerProductIDsBeforeCounter returns a count of RepositoryMock.SellerProductIDs invocations
func (mmSellerProductIDs *RepositoryMock) SellerProductIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSellerProductIDs.beforeSellerProductIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.SellerProductIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSellerProductIDs *mRepositoryMockSellerProductIDs) Calls() []*RepositoryMockSellerProductIDsParams {
	mmSellerProductIDs.mutex.RLock()

	argCopy := make([]*RepositoryMockSellerProductIDsParams, len(mmSellerProductIDs.callArgs))
	copy(argCopy, mmSellerProductIDs.callArgs)

	mmSellerProductIDs.mutex.RUnlock()

	return argCopy
}

// MinimockSellerProductIDsDone returns true if the count of the SellerProductIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockSellerProductIDsDone() bool {
	for _, e := range m.SellerProductIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SellerProductIDsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSellerProductIDsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSellerProductIDs != nil && mm_atomic.LoadUint64(&m.afterSellerProductIDsCounter) < 1 {
		return false
	}
	return true
}

// MinimockSellerProductIDsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockSellerProductIDsInspect() {
	for _, e := range m.SellerProductIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.SellerProductIDs with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SellerProductIDsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSellerProductIDsCounter) < 1 {
		if m.SellerProductIDsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.SellerProductIDs")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.SellerProductIDs with params: %#v", *m.SellerProductIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSellerProductIDs != nil && mm_atomic.LoadUint64(&m.afterSellerProductIDsCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.SellerProductIDs")
	}
}

type mRepositoryMockSellerProducts struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockSellerProductsExpectation
	expectations       []*RepositoryMockSellerProductsExpectation

	callArgs []*RepositoryMockSellerProductsParams
	mutex    sync.RWMutex
}

// RepositoryMockSellerProductsExpectation specifies expectation struct of the Repository.SellerProducts
type RepositoryMockSellerProductsExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockSellerProductsParams
	results *RepositoryMockSellerProductsResults
	Counter uint64
}

// RepositoryMockSellerProductsParams contains parameters of the Repository.SellerProducts
type RepositoryMockSellerProductsParams struct {
	sellerId uint64
}

// RepositoryMockSellerProductsResults contains results of the Repository.SellerProducts
type RepositoryMockSellerProductsResults struct {
	pa1 []models.Product
	err error
}

// Expect sets up expected params for Repository.SellerProducts
func (mmSellerProducts *mRepositoryMockSellerProducts) Expect(sellerId uint64) *mRepositoryMockSellerProducts {
	if mmSellerProducts.mock.funcSellerProducts != nil {
		mmSellerProducts.mock.t.Fatalf("RepositoryMock.SellerProducts mock is already set by Set")
	}

	if mmSellerProducts.defaultExpectation == nil {
		mmSellerProducts.defaultExpectation = &RepositoryMockSellerProductsExpectation{}
	}

	mmSellerProducts.defaultExpectation.params = &RepositoryMockSellerProductsParams{sellerId}
	for _, e := range mmSellerProducts.expectations {
		if minimock.Equal(e.params, mmSellerProducts.defaultExpectation.params) {
			mmSellerProducts.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSellerProducts.defaultExpectation.params)
		}
	}

	return mmSellerProducts
}

// Inspect accepts an inspector function that has same arguments as the Repository.SellerProducts
func (mmSellerProducts *mRepositoryMockSellerProducts) Inspect(f func(sellerId uint64)) *mRepositoryMockSellerProducts {
	if mmSellerProducts.mock.inspectFuncSellerProducts != nil {
		mmSellerProducts.mock.t.Fatalf("Inspect function is already set for RepositoryMock.SellerProducts")
	}

	mmSellerProducts.mock.inspectFuncSellerProducts = f

	return mmSellerProducts
}

// Return sets up results that will be returned by Repository.SellerProducts
func (mmSellerProducts *mRepositoryMockSellerProducts) Return(pa1 []models.Product, err error) *RepositoryMock {
	if mmSellerProducts.mock.funcSellerProducts != nil {
		mmSellerProducts.mock.t.Fatalf("RepositoryMock.SellerProducts mock is already set by Set")
	}

	if mmSellerProducts.defaultExpectation == nil {
		mmSellerProducts.defaultExpectation = &RepositoryMockSellerProductsExpectation{mock: mmSellerProducts.mock}
	}
	mmSellerProducts.defaultExpectation.results = &RepositoryMockSellerProductsResults{pa1, err}
	return mmSellerProducts.mock
}

// Set uses given function f to mock the Repository.SellerProducts method
func (mmSellerProducts *mRepositoryMockSellerProducts) Set(f func(sellerId uint64) (pa1 []models.Product, err error)) *RepositoryMock {
	if mmSellerProducts.defaultExpectation != nil {
		mmSellerProducts.mock.t.Fatalf("Default expectation is already set for the Repository.SellerProducts method")
	}

	if len(mmSellerProducts.expectations) > 0 {
		mmSellerProducts.mock.t.Fatalf("Some expectations are already set for the Repository.SellerProducts method")
	}

	mmSellerProducts.mock.funcSellerProducts = f
	return mmSellerProducts.mock
}

// When sets expectation for the Repository.SellerProducts which will trigger the result defined by the following
// Then helper
func (mmSellerProducts *mRepositoryMockSellerProducts) When(sellerId uint64) *RepositoryMockSellerProductsExpectation {
	if mmSellerProducts.mock.funcSellerProducts != nil {
		mmSellerProducts.mock.t.Fatalf("RepositoryMock.SellerProducts mock is already set by Set")
	}

	expectation := &RepositoryMockSellerProductsExpectation{
		mock:   mmSellerProducts.mock,
		params: &RepositoryMockSellerProductsParams{sellerId},
	}
	mmSellerProducts.expectations = append(mmSellerProducts.expectations, expectation)
	return expectation
}

// Then sets up Repository.SellerProducts return parameters for the expectation previously defined by the When method
func (e *RepositoryMockSellerProductsExpectation) Then(pa1 []models.Product, err error) *RepositoryMock {
	e.results = &RepositoryMockSellerProductsResults{pa1, err}
	return e.mock
}

// SellerProducts implements Repository
func (mmSellerProducts *RepositoryMock) SellerProducts(sellerId uint64) (pa1 []models.Product, err error) {
	mm_atomic.AddUint64(&mmSellerProducts.beforeSellerProductsCounter, 1)
	defer mm_atomic.AddUint64(&mmSellerProducts.afterSellerProductsCounter, 1)

	if mmSellerProducts.inspectFuncSellerProducts != nil {
		mmSellerProducts.inspectFuncSellerProducts(sellerId)
	}

	mm_params := &RepositoryMockSellerProductsParams{sellerId}

	// Record call args
	mmSellerProducts.SellerProductsMock.mutex.Lock()
	mmSellerProducts.SellerProductsMock.callArgs = append(mmSellerProducts.SellerProductsMock.callArgs, mm_params)
	mmSellerProducts.SellerProductsMock.mutex.Unlock()

	for _, e := range mmSellerProducts.SellerProductsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.err
		}
	}

	if mmSellerProducts.SellerProductsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSellerProducts.SellerProductsMock.defaultExpectation.Counter, 1)
		mm_want := mmSellerProducts.SellerProductsMock.defaultExpectation.params
		mm_got := RepositoryMockSellerProductsParams{sellerId}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSellerProducts.t.Errorf("RepositoryMock.SellerProducts got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSellerProducts.SellerProductsMock.defaultExpectation.results
		if mm_results == nil {
			mmSellerProducts.t.Fatal("No results are set for the RepositoryMock.SellerProducts")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmSellerProducts.funcSellerProducts != nil {
		return mmSellerProducts.funcSellerProducts(sellerId)
	}
	mmSellerProducts.t.Fatalf("Unexpected call to RepositoryMock.SellerProducts. %v", sellerId)
	return
}

// SellerProductsAfterCounter returns a count of finished RepositoryMock.SellerProducts invocations
func (mmSellerProducts *RepositoryMock) SellerProductsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSellerProducts.afterSellerProductsCounter)
}

// SellerProductsBeforeCounter returns a count of RepositoryMock.SellerProducts invocations
func (mmSellerProducts *RepositoryMock) SellerProductsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSellerProducts.beforeSellerProductsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.SellerProducts.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSellerProducts *mRepositoryMockSellerProducts) Calls() []*RepositoryMockSellerProductsParams {
	mmSellerProducts.mutex.RLock()

	argCopy := make([]*RepositoryMockSellerProductsParams, len(mmSellerProducts.callArgs))
	copy(argCopy, mmSellerProducts.callArgs)

	mmSellerProducts.mutex.RUnlock()

	return argCopy
}

// MinimockSellerProductsDone returns true if the count of the SellerProducts invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockSellerProductsDone() bool {
	for _, e := range m.SellerProductsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SellerProductsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSellerProductsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSellerProducts != nil && mm_atomic.LoadUint64(&m.afterSellerProductsCounter) < 1 {
		return false
	}
	return true
}

// MinimockSellerProductsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockSellerProductsInspect() {
	for _, e := range m.SellerProductsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.SellerProducts with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SellerProductsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSellerProductsCounter) < 1 {
		if m.SellerProductsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.SellerProducts")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.SellerProducts with params: %#v", *m.SellerProductsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSellerProducts != nil && mm_atomic.LoadUint64(&m.afterSellerProductsCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.SellerProducts")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockManageProductsInspect()

		m.MinimockProductsByFilterInspect()

		m.MinimockSellerProductIDsInspect()

		m.MinimockSellerProductsInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockManageProductsDone() &&
		m.MinimockProductsByFilterDone() &&
		m.MinimockSellerProductIDsDone() &&
		m.MinimockSellerProductsDone()
}
